import{b as o,o as u,w as a,g as e,ad as t,v as m,x as i,T as s}from"./modules/vue-3MX-AAUY.js";import{I as c}from"./slidev/default-N-ojdLkz.js";import{u as p,f as d}from"./slidev/context-CCvA-To0.js";import"./index-CPDaYc2D.js";import"./modules/shiki-DyOxNjFt.js";const M={__name:"slides.md__slidev_11",setup(_){const{$clicksContext:r,$frontmatter:n}=p();return r.setup(),(g,l)=>(u(),o(c,m(i(s(d)(s(n),10))),{default:a(()=>[...l[0]||(l[0]=[e("h1",null,"COMBINING GEM5 AND TLM",-1),e("p",null,"需要结合二者的机制来同时满足 retry 和 exclusion rules，规则复杂但是实现还是比较简单",-1),e("ul",null,[e("li",null,[t("从 gem5 到 SystemC：当 TLM 方忙时，如何让 gem5 停下来并在 TLM 空闲时自动重试？ "),e("ul",null,[e("li",null,"忙拒绝：gem5会通过req函数的返回值判断是否成功发出请求，TLM方忙的时候给出一个标志，当这个标志为真时return false即可，在实现中，当TLM处于BEGIN_REQ时会有一个blockingRequest"),e("li",null,"空闲时重试：TLM进入END_REQ阶段时会解除阻塞然后检查是否有被拒绝的请求，如果有则发起gem5::sendRetryReq")])]),e("li",null,[t("从 SystemC 到 gem5：当 gem5 忙时，如何利用 gem5 的规则卡住 SystemC 发起方？ "),e("ul",null,[e("li",null,"利用 gem5的忙拒绝机制，TLM 调用 sendTimingReq 如果为 false 则卡住，然后标记需要retry，由于TLM exclusion机制，此时会卡在这里，也不会有下一个BEGIN_REQ发过来"),e("li",null,"gem5空闲时（上一个请求进入END_REQ时）会唤醒systemc，通过sendReqRetry调用到 recvReqRetry，这个函数内部会唤醒那个pending的req，重新发送BEGIN_REQ，此时")])])],-1)])]),_:1},16))}};export{M as default};
